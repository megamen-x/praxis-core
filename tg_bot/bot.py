import os
import io
import asyncio
import traceback
import tempfile
from typing import Any, List, Optional, Dict

import httpx

from aiogram import Bot, Dispatcher, F
from aiogram.client.default import DefaultBotProperties
from aiogram.enums import ParseMode
from aiogram.filters import Command
from aiogram.types import Message, InlineKeyboardButton, CallbackQuery, FSInputFile
from aiogram.utils.keyboard import InlineKeyboardBuilder

from db.session import Database
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class Praxis_bot:
    """
    The main class for the Praxis assistant bot.
    It encapsulates all the logic for handling messages, interacting with external APIs,
    and managing the bot's lifecycle.
    """

    # --------------------------------------------------------------------------- #
    # === Constants for messages and callbacks ================================== #
    # --------------------------------------------------------------------------- #

    GREETING_MESSAGE = "–ü—Ä–∏–≤–µ—Ç! –ú–µ–Ω—è –∑–æ–≤—É—Ç Minerva, –∫–∞–∫ —Ç–µ–±–µ –ø–æ–º–æ—á—å?"
    ABOUT_MESSAGE = "MINERVA - –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–π –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç —Å–ª—É–∂–±—ã –ø–æ–¥–¥–µ—Ä–∂–∫–∏"
    PROCESSING_MESSAGE = "üí¨"
    GENERAL_ERROR_MESSAGE = "–ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ –ø–æ–∑–∂–µ."
    UNSUPPORTED_TYPE_MESSAGE = "–û—à–∏–±–∫–∞! –¢–∞–∫–æ–π —Ç–∏–ø —Å–æ–æ–±—â–µ–Ω–∏–π –ø–æ–∫–∞ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è!"
    API_RESPONSE_ERROR_MESSAGE = "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –æ—Ç–≤–µ—Ç –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞."
    
    FEEDBACK_CALLBACK_PREFIX = "feedback:"
    LIKE_CALLBACK_DATA = f"{FEEDBACK_CALLBACK_PREFIX}like"
    DISLIKE_CALLBACK_DATA = f"{FEEDBACK_CALLBACK_PREFIX}dislike"
    ANSWER_MODE_CALLBACK_PREFIX = "ansmode:"
    FULL_MODE_CALLBACK = f"{ANSWER_MODE_CALLBACK_PREFIX}full"
    SHORT_MODE_CALLBACK = f"{ANSWER_MODE_CALLBACK_PREFIX}short"
    

    def __init__(self, bot_token: str, db_path: str, rag_url: str, transcription_url: str):
        """
        Initializes the bot, database, and dispatcher.

        :param bot_token: The token for the Telegram Bot API.
        :param db_path: The path to the SQLite database file.
        :param api_url: The URL for the query processing API.
        :param transcription_url: The URL for the query transcription API. 
        """
        logger.info("–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—Ç–∞")
        self.db = Database(db_path)
        self.rag_url = rag_url
        self.transcription_url = transcription_url
        
        self.bot = Bot(token=bot_token, default=DefaultBotProperties(parse_mode=ParseMode.MARKDOWN))
        self.dp = Dispatcher()
        
        self._likes_kb = self._build_feedback_keyboard()
        self._answer_mode_kb = self._build_answer_mode_keyboard()
        self._register_handlers()

        self.user_answer_mod: Dict[int, str] = {}
        self.user_states: Dict[int, str] = {}
        logger.info("–ë–æ—Ç —É—Å–ø–µ—à–Ω–æ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")

    def _build_feedback_keyboard(self) -> InlineKeyboardBuilder:
        """Builds the inline keyboard for feedback."""
        builder = InlineKeyboardBuilder()
        builder.add(InlineKeyboardButton(text="üëç", callback_data=self.LIKE_CALLBACK_DATA))
        builder.add(InlineKeyboardButton(text="üëé", callback_data=self.DISLIKE_CALLBACK_DATA))
        return builder
    
    def _build_answer_mode_keyboard(self) -> InlineKeyboardBuilder:
        """Builds the inline keyboard for answer mode."""
        builder = InlineKeyboardBuilder()
        builder.add(
            InlineKeyboardButton(text="üìú –ü–æ–ª–Ω—ã–π –æ—Ç–≤–µ—Ç",  callback_data=self.FULL_MODE_CALLBACK),
            InlineKeyboardButton(text="‚úÇÔ∏è –ö—Ä–∞—Ç–∫–∏–π –æ—Ç–≤–µ—Ç", callback_data=self.SHORT_MODE_CALLBACK),
        )
        return builder

    def _register_handlers(self):
        """Registers all message and callback handlers for the dispatcher."""
        self.dp.message.register(self.start_command, Command("start"))
        self.dp.message.register(self.answer_mode_command, Command("answer_mode"))
        self.dp.message.register(self.indexing_command, Command("indexing"))
        
        self.dp.message.register(self._handle_text, F.text)
        self.dp.message.register(self._handle_voice, F.voice)
        self.dp.message.register(self._handle_document, F.document)
        
        self.dp.callback_query.register(self._handle_feedback_callback, F.data.startswith(self.FEEDBACK_CALLBACK_PREFIX))
        self.dp.callback_query.register(self._handle_answer_mode_callback, F.data.startswith(self.ANSWER_MODE_CALLBACK_PREFIX))

    async def start_polling(self):
        """Starts the bot's polling loop."""
        await self.dp.start_polling(self.bot)

    async def start_command(self, message: Message):
        """
        Handles the /start command. Creates a new conversation for the user.
        
        :param message: The incoming message object from aiogram.
        """
        self.db.create_conv_id(message.chat.id)
        await message.reply(self.GREETING_MESSAGE)
    
    async def answer_mode_command(self, message: Message):
        """Show the user keyboard to select answer mode."""
        markup = self._answer_mode_kb.as_markup()
        await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ —Ä–µ–∂–∏–º –æ—Ç–≤–µ—Ç–∞:", reply_markup=markup)

    async def indexing_command(self, message: Message):
        """
        Processes the /indexing command - prompts the user to send 
        a ZIP file for indexing and informs them about the current database.
        
        :param message: Incoming message.
        """
        user_id = message.from_user.id if message.from_user else None
        if not user_id:
            return
        try:
            async with httpx.AsyncClient(timeout=15.0) as client:
                response = await client.get(self.rag_url + 'get_database_name/')
                response.raise_for_status()
                data = response.json()
                db_name = data.get("message", "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ")
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∏–º–µ–Ω–∏ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö: {e}")
            return "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∏–º—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö"
        
        self.user_states[user_id] = "waiting_for_zip"

        await message.reply(
            text=f"–¢–µ–∫—É—â–∞—è –±–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö: {db_name}\n\n"
            "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ ZIP-—Ñ–∞–π–ª —Å –¥–æ–∫—É–º–µ–Ω—Ç–∞–º–∏ –¥–ª—è –∏–Ω–¥–µ–∫—Å–∞—Ü–∏–∏.\n"
            "–ï—Å–ª–∏ –∏–º—è —Ñ–∞–π–ª–∞ —Å–æ–≤–ø–∞–¥–∞–µ—Ç —Å —Ç–µ–∫—É—â–∏–º –∏–º–µ–Ω–µ–º –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö, –æ–Ω–∞ –±—É–¥–µ—Ç –æ–±–Ω–æ–≤–ª–µ–Ω–∞.\n"
            "–í –ø—Ä–æ—Ç–∏–≤–Ω–æ–º —Å–ª—É—á–∞–µ –±—É–¥–µ—Ç —Å–æ–∑–¥–∞–Ω–∞ –Ω–æ–≤–∞—è –±–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö.",
            parse_mode=None
        )
        
    def _get_user_full_name(self, message: Message) -> Optional[str]:
        """
        Safely retrieves the user's full name or username.

        :param message: The message object.
        :return: User's full name, username, or None.
        """
        if not message.from_user:
            return None
        return message.from_user.full_name or message.from_user.username

    async def _handle_text(self, message: Message):
        """
        Handles an incoming text message by querying the API.
        
        :param message: The incoming message object.
        """
        if not message.text:
            return
        await self._process_content(message, message.text)
    
    async def _handle_voice(self, message: Message):
        """
        Handles an incoming voice message by transcribing it and then querying the API.

        :param message: The incoming message object.
        """
        user_id = message.from_user.id if message.from_user else None

        placeholder = await message.answer(f"üé§ –†–∞—Å–ø–æ–∑–Ω–∞—é –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ...")
        try:
            transcribed_text = await self._transcribe_voice(message)
            await placeholder.delete()
            await self._process_content(message, transcribed_text)
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}: {e}")
            traceback.print_exc()
            await placeholder.edit_text(f"–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å —Ä–µ—á—å: {e}")

    async def _handle_document(self, message: Message):
        """
        Handles an incoming document (CSV, Excel, ZIP) for processing.

        :param message: The incoming message object.
        """
        user_id = message.from_user.id if message.from_user else None

        if self.user_states.get(user_id) == "waiting_for_zip":
            await self._handle_zip_for_indexing(message)
            self.user_states.pop(user_id, None)
            return

        content = await self._parse_document(message)
        if content is None:
            await message.answer(self.UNSUPPORTED_TYPE_MESSAGE)
            return

        placeholder = await message.answer(f"–û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é —Ñ–∞–π–ª...")
        try:
            logger.debug(f"–û—Ç–ø—Ä–∞–≤–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ –∫ API –¥–ª—è –ø–∞–∫–µ—Ç–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}")
            full_ans, short_ans, docs = await self._query_api(content)
            df = pd.DataFrame({'Question': content, 'Short Answer': short_ans, 'Full Answer': full_ans, 'Documents': docs})
            
            with tempfile.NamedTemporaryFile(mode='w+', delete=False, suffix='.csv', encoding='utf-8') as tmp_file:
                df.to_csv(tmp_file.name, index=False)
                await self.bot.send_document(
                    document=FSInputFile(tmp_file.name, filename="results.csv"), 
                    chat_id=message.chat.id
                )
            os.remove(tmp_file.name)
            await placeholder.delete()

        except Exception:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–∞–∫–µ—Ç–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–µ –¥–æ–∫—É–º–µ–Ω—Ç–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}: {e}")
            traceback.print_exc()
            await placeholder.edit_text(self.GENERAL_ERROR_MESSAGE)

    async def _process_content(self, message: Message, content: Any):
        """
        A generic function to process content, save it, query the API, and send a response.
        
        :param message: The original message to reply to.
        :param content: The content to be processed (text or list of texts).
        """
        user_id = message.from_user.id
        user_name = self._get_user_full_name(message)
        conv_id = self.db.get_current_conv_id(user_id)

        self.db.save_user_message(content, conv_id=conv_id, user_id=user_id, user_name=user_name)
        placeholder = await message.answer(self.PROCESSING_MESSAGE)

        try:
            full_ans, short_ans, docs = await self._query_api([content])

            mode = self.user_answer_mod.get(user_id, self.DEFAULT_ANSWER_MODE)
            answer_text = full_ans[0] if mode == "full" else short_ans[0]
            docs_text = ", ".join(docs[0])
            final_answer = (
                f"{answer_text}\n"
                f"===========================\n"
                f"–î–æ–∫—É–º–µ–Ω—Ç—ã:\n{docs_text}"
            )

            markup = self._likes_kb.as_markup()
            new_message = await placeholder.edit_text(final_answer, parse_mode=None, reply_markup=markup)

            self.db.save_assistant_message(
                content=final_answer,
                conv_id=conv_id,
                message_id=new_message.message_id,
            )
        except httpx.RequestError as exc:
            logger.error(f"–û—à–∏–±–∫–∞ —Å–µ—Ç–∏ –ø—Ä–∏ –∑–∞–ø—Ä–æ—Å–µ –∫ API –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}: {exc}")
            await placeholder.edit_text(f"–û—à–∏–±–∫–∞ —Å–µ—Ç–∏. –ù–µ –º–æ–≥—É —Å–≤—è–∑–∞—Ç—å—Å—è —Å —Å–µ—Ä–≤–µ—Ä–æ–º. {exc}")
        except Exception:
            logger.error(f"–û–±—â–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}")
            traceback.print_exc()
            await placeholder.edit_text(self.GENERAL_ERROR_MESSAGE)

    async def _handle_feedback_callback(self, callback: CallbackQuery):
        """
        Handles a feedback callback (like/dislike).

        :param callback: The callback query object.
        """
        if not callback.data: return
        user_id = callback.from_user.id
        message_id = callback.message.message_id
        feedback = callback.data.replace(self.FEEDBACK_CALLBACK_PREFIX, "")
        is_correct = 1 if feedback == 'dislike' else 0

        self.db.save_feedback(feedback, user_id=user_id, message_id=message_id, is_correct=is_correct)
        await self.bot.edit_message_reply_markup(
            chat_id=callback.message.chat.id,
            message_id=message_id,
            reply_markup=None
        )
        await callback.answer(f"–°–ø–∞—Å–∏–±–æ –∑–∞ –≤–∞—à –æ—Ç–∑—ã–≤: {feedback}!")

    async def _handle_answer_mode_callback(self, callback: CallbackQuery):
        """
        Handles a answer mode callback (full/short).
        
        :param callback: The callback query object.
        """
        if not callback.data:
            return

        mode = callback.data.replace(self.ANSWER_MODE_CALLBACK_PREFIX, "")

        if mode not in self.SUPPORTED_MODES:
            await callback.answer("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ä–µ–∂–∏–º.")
            return

        user_id = callback.from_user.id
        self.user_answer_mod[user_id] = mode

        text = "–ü–æ–ª–Ω—ã–π" if mode=='full' else '–ö—Ä–∞—Ç–∫–∏–π'
        await callback.message.edit_text(
            text='–£—Å–ø–µ—à–Ω–æ —Å–º–µ–Ω–∏–ª–∏ —Ä–µ–∂–∏–º –Ω–∞: ' + text,
            parse_mode=None,
            reply_markup=None
            )
        await callback.answer(f"‚úÖ –†–µ–∂–∏–º –æ—Ç–≤–µ—Ç–∞ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –Ω–∞ ¬´{mode}¬ª")

    async def _query_api(self, user_content: List[str]) -> List[str]:
        """
        Sends a request to the processing API.

        :param user_content: The user's message content (string or list of strings).
        :return: A list of answers from the model.
        :raises httpx.RequestError: If a network-related error occurs.
        :raises httpx.HTTPStatusError: If the server returns a 4xx or 5xx response.
        :raises KeyError: If the 'answer' key is not in the response JSON.
        """
        question = {'question': user_content}
        async with httpx.AsyncClient(timeout=60.0) as client:
            response = await client.post(self.rag_url + 'request_processing/', json=question)
            response.raise_for_status()
            data = response.json()
            
            for k in ("full_answer", "short_answer", "docs"):
                if k not in data:
                    raise KeyError(self.API_RESPONSE_ERROR_MESSAGE)

            return data["full_answer"], data["short_answer"], data["docs"]

    async def _transcribe_voice(self, message: Message) -> str:
        """
        Downloads a voice message, converts it, and transcribes it.

        :param message: The message with the voice file.
        :return: The transcribed text.
        """
        if not message.voice:
            return ""

        user_id = message.from_user.id if message.from_user else None

        try:
            voice_file = await self.bot.get_file(message.voice.file_id)

            voice_ogg_buffer = io.BytesIO()
            await self.bot.download_file(voice_file.file_path, destination=voice_ogg_buffer)
            voice_ogg_buffer.seek(0)

            files = {
                'file': ('voice.ogg', voice_ogg_buffer, 'audio/ogg')
            }

            async with httpx.AsyncClient(timeout=60.0) as client:
                response = await client.post(self.transcription_url, files=files)
                response.raise_for_status()
                data = response.json()
                return data.get("transcription", "")

        except httpx.HTTPStatusError as e:
            logger.error(f"HTTP –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏–∏ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}: {e.response.status_code} - {e.response.text}")
            return "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–∞—à–µ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è."
        except httpx.RequestError as e:
            logger.error(f"–û—à–∏–±–∫–∞ —Å–µ—Ç–∏ –ø—Ä–∏ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏–∏ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}: {e}")
            return "–°–µ—Ä–≤–∏—Å —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏–∏ –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω."
        except Exception as e:
            return "–ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫."

    async def _handle_zip_for_indexing(self, message: Message):
        """
        Processes the ZIP file for indexing by sending it to the server.
        
        :param message: A message with an attached ZIP file.
        """
            
        file_name = message.document.file_name
        if not file_name or not file_name.lower().endswith('.zip'):
            await message.reply("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–∞–π–ª —Å —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ–º .zip")
            return
            
        placeholder = await message.reply("‚è≥ –û—Ç–ø—Ä–∞–≤–∫–∞ —Ñ–∞–π–ª–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä –¥–ª—è –∏–Ω–¥–µ–∫—Å–∞—Ü–∏–∏...")
        
        try:
            file_info = await self.bot.get_file(message.document.file_id)
            file_data = await self.bot.download_file(file_info.file_path)
            
            files = {'file': (file_name, file_data, 'application/zip')}
            
            async with httpx.AsyncClient(timeout=3600.0) as client:
                response = await client.post(self.rag_url + 'index/', files=files)
                response.raise_for_status()
                result = response.json()
                await placeholder.edit_text(f"‚úÖ {result.get('message', '–ò–Ω–¥–µ–∫—Å–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ.')}")
                
        except httpx.HTTPStatusError as e:
            error_msg = f"–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞: {e.response.status_code}"
            try:
                error_detail = e.response.json().get('detail', '')
                if error_detail:
                    error_msg += f" - {error_detail}"
            except:
                pass
            logger.error(f"HTTP –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∏–Ω–¥–µ–∫—Å–∞—Ü–∏–∏: {error_msg}")
            await placeholder.edit_text(f"‚ùå {error_msg}")
        except httpx.RequestError as e:
            logger.error(f"–û—à–∏–±–∫–∞ —Å–µ—Ç–∏ –ø—Ä–∏ –∏–Ω–¥–µ–∫—Å–∞—Ü–∏–∏: {e}")
            await placeholder.edit_text(f"‚ùå –û—à–∏–±–∫–∞ —Å–µ—Ç–∏: {e}")
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–Ω–¥–µ–∫—Å–∞—Ü–∏–∏: {e}")
            traceback.print_exc()
            await placeholder.edit_text(f"‚ùå –û—à–∏–±–∫–∞: {e}")

    async def _parse_document(self, message: Message) -> Optional[List[str]]:
        """
        Parses a document (CSV/XLSX) to extract a list of questions.

        :param message: The message with the document.
        :return: A list of strings or None if the format is unsupported.
        """
        if not message.document: return None

        user_id = message.from_user.id if message.from_user else None
        file_name = message.document.file_name or ""
        file_extension = file_name.split('.')[-1].lower()
        
        logger.debug(f"–ü–∞—Ä—Å–∏–Ω–≥ –¥–æ–∫—É–º–µ–Ω—Ç–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}: {file_name} (—Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ: {file_extension})")

        with tempfile.NamedTemporaryFile(suffix=f".{file_extension}") as tmp_file:
            file_info = await self.bot.get_file(message.document.file_id)
            await self.bot.download_file(file_info.file_path, tmp_file.name)
            
            try:
                if file_extension == "csv":
                    df = pd.read_csv(tmp_file.name)
                    if self.CSV_REQUIRED_COLUMN not in [el.lower() for el in df.columns]:
                        await message.reply(f"–û—à–∏–±–∫–∞: –≤ CSV —Ñ–∞–π–ª–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–∞—è –∫–æ–ª–æ–Ω–∫–∞ '{self.CSV_REQUIRED_COLUMN}'.")
                        return None
                    return df[self.CSV_REQUIRED_COLUMN].dropna().astype(str).to_list()
                
                elif file_extension in ["xls", "xlsx"]:
                    df = pd.read_excel(tmp_file.name)
                    return df.iloc[:, 0].dropna().astype(str).to_list()

            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–∞—Ä—Å–∏–Ω–≥–µ –¥–æ–∫—É–º–µ–Ω—Ç–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}: {e}")
                await message.reply(f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å —Ñ–∞–π–ª: {e}")
                return None
        return None

def main():
    """
    Main entry point for the bot.
    Initializes and starts the Minerva bot.
    Configuration is loaded from environment variables.
    
    """
    bot_token = os.getenv("BOT_TOKEN")
    rag_url = os.getenv("RAG_URL")
    transcription_url = os.getenv("TRANSCRIPTION_URL")
    db_path = os.getenv('DB_PATH', 'minerva.db')
    if not bot_token:
        raise ValueError("BOT_TOKEN environment variable not set!")

    bot = Minerva(bot_token=bot_token, db_path=db_path, rag_url=rag_url, transcription_url=transcription_url)
    asyncio.run(bot.start_polling())


if __name__ == "__main__":
    fire.Fire(main)