import asyncio
import aiohttp
from aiogram import Bot, Dispatcher, types, Router, F
from aiogram.filters import Command
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton, WebAppInfo
from aiogram.utils.keyboard import ReplyKeyboardBuilder, InlineKeyboardBuilder
from datetime import datetime, timedelta
import aioschedule
from typing import List, Optional
import pytz
import json
import httpx

# SQLAlchemy imports
from sqlalchemy import create_engine, Column, Integer, String, DateTime, Text, Boolean
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from sqlalchemy.future import select
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession, async_sessionmaker

import logging

from models.user import User
from models.broadcast import Broadcast
from models.review import Review
from db.session import Base, engine

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# –¢–æ–∫–µ–Ω –±–æ—Ç–∞
BOT_TOKEN = "8096053221:AAFtVtvlGyiHJOtRQWbCbd1_C2LqTVzGM9Y"

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—Ç–∞ –∏ –¥–∏—Å–ø–µ—Ç—á–µ—Ä–∞
bot = Bot(token=BOT_TOKEN)
dp = Dispatcher()
router = Router()
dp.include_router(router)

# # –°–æ–∑–¥–∞–Ω–∏–µ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–≥–æ –¥–≤–∏–∂–∫–∞
async_session = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
async def init_db():
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)

# –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ –ë–î
async def register_user(user_id: int, username: str, first_name: str, last_name: str) -> bool:
    try:
        async with async_session() as session:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å
            result = await session.execute(
                select(User).where(User.user_id == user_id)
            )
            existing_user = result.scalar_one_or_none()
            
            if not existing_user:
                new_user = User(
                    user_id=user_id,
                    first_name=first_name,
                    last_name=last_name,
                    can_create_review=True,
                    created_at=datetime.utcnow(),
                )
                session.add(new_user)
            
            await session.commit()
            return True
            
    except Exception as e:
        logger.error(f"Error registering user: {e}")
        return False

# –ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Å–µ—Ö –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
async def get_all_users() -> List[int]:
    try:
        async with async_session() as session:
            result = await session.execute(
                select(User.user_id).where(User.is_active == True)
            )
            users = [row[0] for row in result.all()]
            return users
    except Exception as e:
        logger.error(f"Error getting users: {e}")
        return []

# –ü–æ–ª—É—á–µ–Ω–∏–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
async def get_reviews_by_user(user_id: str) -> int:
    try:
        async with async_session() as session:
            result = await session.execute(
                select(Review).where(Review.created_by_user_id == user_id)
            )
            return result.scalars().all()
    except Exception as e:
        logger.error(f"Error getting users count: {e}")
        return 0

async def get_users_count() -> int:
    try:
        async with async_session() as session:
            result = await session.execute(
                select(User)
            )
            return len(result.scalars().all())
    except Exception as e:
        logger.error(f"Error getting users count: {e}")
        return 0

# –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ä–∞—Å—Å—ã–ª–∫–∏ –≤ –ë–î
async def save_broadcast(message_text: str, scheduled_time: datetime) -> Optional[int]:
    try:
        async with async_session() as session:
            new_broadcast = Broadcast(
                message_text=message_text,
                scheduled_time=scheduled_time
            )
            session.add(new_broadcast)
            await session.commit()
            return new_broadcast.id
    except Exception as e:
        logger.error(f"Error saving broadcast: {e}")
        return None

# –ü–æ–ª—É—á–µ–Ω–∏–µ –∞–∫—Ç–∏–≤–Ω—ã—Ö —Ä–∞—Å—Å—ã–ª–æ–∫
async def get_scheduled_broadcasts() -> List[Broadcast]:
    try:
        async with async_session() as session:
            result = await session.execute(
                select(Broadcast).where(
                    Broadcast.status == 'scheduled',
                    Broadcast.scheduled_time > datetime.utcnow()
                ).order_by(Broadcast.scheduled_time)
            )
            return result.scalars().all()
    except Exception as e:
        logger.error(f"Error getting broadcasts: {e}")
        return []

# –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ —Ä–∞—Å—Å—ã–ª–∫–∏
async def update_broadcast_status(broadcast_id: int, status: str, 
                                 sent_count: int = 0, failed_count: int = 0) -> bool:
    try:
        async with async_session() as session:
            result = await session.execute(
                select(Broadcast).where(Broadcast.id == broadcast_id)
            )
            broadcast = result.scalar_one_or_none()
            
            if broadcast:
                broadcast.status = status
                broadcast.sent_count = sent_count
                broadcast.failed_count = failed_count
                await session.commit()
                return True
            return False
    except Exception as e:
        logger.error(f"Error updating broadcast status: {e}")
        return False

# –°–æ–∑–¥–∞–Ω–∏–µ –æ—Å–Ω–æ–≤–Ω–æ–π –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã
def create_main_keyboard():
    builder = ReplyKeyboardBuilder()
    
    # –ö–Ω–æ–ø–∫–∞ –¥–ª—è –∞–¥–º–∏–Ω–∞
    builder.row(KeyboardButton(text="üìù –°–æ–∑–¥–∞—Ç—å —Ñ–æ—Ä–º—É"))
    builder.row(KeyboardButton(text="üìù –ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Å–ø–∏—Å–æ–∫ —Å–æ–∑–¥–∞–Ω–Ω—ã—Ö —Ñ–æ—Ä–º"))
    builder.row(KeyboardButton(text="‚¨ÖÔ∏è –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é"))
    return builder.as_markup(resize_keyboard=True)

# –°–æ–∑–¥–∞–Ω–∏–µ –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã –∞–¥–º–∏–Ω–∞
def create_admin_keyboard():
    builder = ReplyKeyboardBuilder()
    builder.row(KeyboardButton(text="üìù –°–æ–∑–¥–∞—Ç—å —Ñ–æ—Ä–º—É"))
    builder.row(KeyboardButton(text="‚¨ÖÔ∏è –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é"))
    return builder.as_markup(resize_keyboard=True)

ADMIN_IDS = [12345678]  # –í–∞—à Telegram ID

# –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–∞–≤ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞
def is_admin(user_id: int) -> bool:
    return user_id in ADMIN_IDS

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /start
@router.message(Command("start"))
async def cmd_start(message: types.Message):
    user = message.from_user
    success = await register_user(
        user_id=user.id,
        username=user.username,
        first_name=user.first_name,
        last_name=user.last_name or ""
    )
    
    if success:
        welcome_text = f"üëã –ü—Ä–∏–≤–µ—Ç, {user.first_name}!\n‚úÖ –í—ã —É—Å–ø–µ—à–Ω–æ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã!"
    else:
        welcome_text = f"üëã –ü—Ä–∏–≤–µ—Ç, {user.first_name}!\n–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏."
    
    keyboard = create_main_keyboard()
    await message.answer(welcome_text, reply_markup=keyboard)
    
    # –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∞–¥–º–∏–Ω - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å
    if is_admin(user.id):
        admin_keyboard = create_admin_keyboard()
        await message.answer("üëë –í–∞–º –¥–æ—Å—Ç—É–ø–Ω–∞ –ø–∞–Ω–µ–ª—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞", reply_markup=admin_keyboard)

# –°–æ—Å—Ç–æ—è–Ω–∏—è –¥–ª—è FSM
user_states = {}

@router.message(F.text == "üìù –°–æ–∑–¥–∞—Ç—å —Ñ–æ—Ä–º—É")
async def create_form(message: types.Message):
    if not is_admin(message.from_user.id):
        await message.answer("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –Ω–∞ —Å–æ–∑–¥–∞–Ω–∏–µ —Ñ–æ—Ä–º—ã")
        return
    
    try: 
        await message.answer('–í–≤–µ–¥–∏—Ç–µ —Ç–µ–≥ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –ø–æ –∫–æ—Ç–æ—Ä–æ–º—É —Å–æ–∑–¥–∞–Ω–∞ —Ñ–æ—Ä–º–∞')
        user_states[message.from_user.id] = 'form_creating_tag_subject_user_id'
        
    except Exception as e:
        logger.error(f"Error getting stats: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ —Ñ–æ—Ä–º—ã")


@router.message(F.text == "üìù –ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Å–ø–∏—Å–æ–∫ —Å–æ–∑–¥–∞–Ω–Ω—ã—Ö —Ñ–æ—Ä–º")
async def list_forms(message: types.Message):
    if not is_admin(message.from_user.id):
        await message.answer("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –Ω–∞ –ø—Ä–æ—Å–º–æ—Ç—Ä —Å–ø–∏—Å–∫–∞ —Ñ–æ—Ä–º")
        return
    
    try: 
        
        forms = get_reviews_by_user(user_id='ae15f59e-f572-4d28-9ad5-640014288f7b')
        print(forms)
        if not forms:
            await message.answer("üì≠ –ù–µ—Ç —Å–æ–∑–¥–∞–Ω–Ω—ã—Ö —Ñ–æ—Ä–º")
            return
        
        response_text = "üìã –°–ø–∏—Å–æ–∫ —Å–æ–∑–¥–∞–Ω–Ω—ã—Ö —Ñ–æ—Ä–º:\n\n"
        for form in forms:
            response_text += f"ID: {form['id']}\n"
            # response_text += f"–¢–µ–≥ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {form['subject_user_id']}\n"
            response_text += f"–°–æ–∑–¥–∞–Ω–æ: {form['created_at']}\n"
            
        await message.answer(response_text)
        
    except Exception as e:
        logger.error(f"Error getting forms: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–ø–∏—Å–∫–∞ —Ñ–æ—Ä–º")

# # –û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
# @router.message(F.text == "üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞")
# async def show_stats(message: types.Message):
#     if not is_admin(message.from_user.id):
#         await message.answer("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏")
#         return
    
#     try:
#         total_users = await get_users_count()
#         broadcasts = await get_scheduled_broadcasts()
#         active_broadcasts = len(broadcasts)
        
#         stats_text = (
#             "üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±–æ—Ç–∞:\n\n"
#             f"üë• –í—Å–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {total_users}\n"
#             f"üì® –ê–∫—Ç–∏–≤–Ω—ã—Ö —Ä–∞—Å—Å—ã–ª–æ–∫: {active_broadcasts}\n"
#             f"üïí –í—Ä–µ–º—è —Å–µ—Ä–≤–µ—Ä–∞: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
#         )
        
#         await message.answer(stats_text)
        
#     except Exception as e:
#         logger.error(f"Error getting stats: {e}")
#         await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏")

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Å–æ–∑–¥–∞–Ω–∏—è —Ä–∞—Å—Å—ã–ª–∫–∏
@router.message(F.text == "üì® –°–æ–∑–¥–∞—Ç—å —Ä–∞—Å—Å—ã–ª–∫—É")
async def create_broadcast(message: types.Message):
    if not is_admin(message.from_user.id):
        await message.answer("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —Ä–∞—Å—Å—ã–ª–∫–∏")
        return
    
    user_states[message.from_user.id] = 'awaiting_broadcast_message'
    await message.answer(
        "üìù –í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç —Ä–∞—Å—Å—ã–ª–∫–∏:\n\n"
        "–§–æ—Ä–º–∞—Ç –¥–∞—Ç—ã –∏ –≤—Ä–µ–º–µ–Ω–∏: –ì–ì–ì–ì-–ú–ú-–î–î –ß–ß:–ú–ú\n"
        "–ü—Ä–∏–º–µ—Ä: 2024-12-25 15:30\n\n"
        "–ü–æ—Å–ª–µ —Ç–µ–∫—Å—Ç–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –Ω–∞ –Ω–æ–≤–æ–π —Å—Ç—Ä–æ–∫–µ —É–∫–∞–∂–∏—Ç–µ –¥–∞—Ç—É –∏ –≤—Ä–µ–º—è"
    )

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∞–∫—Ç–∏–≤–Ω—ã—Ö —Ä–∞—Å—Å—ã–ª–æ–∫
@router.message(F.text == "üìã –ê–∫—Ç–∏–≤–Ω—ã–µ —Ä–∞—Å—Å—ã–ª–∫–∏")
async def show_active_broadcasts(message: types.Message):
    if not is_admin(message.from_user.id):
        await message.answer("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ —Ä–∞—Å—Å—ã–ª–æ–∫")
        return
    
    broadcasts = await get_scheduled_broadcasts()
    
    if not broadcasts:
        await message.answer("üì≠ –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö —Ä–∞—Å—Å—ã–ª–æ–∫")
        return
    
    response = "üìã –ê–∫—Ç–∏–≤–Ω—ã–µ —Ä–∞—Å—Å—ã–ª–∫–∏:\n\n"
    for broadcast in broadcasts:
        # –û–±—Ä–µ–∑–∞–µ–º –¥–ª–∏–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç
        preview = broadcast.message_text[:50] + "..." if len(broadcast.message_text) > 50 else broadcast.message_text
        response += f"ID: {broadcast.id}\n"
        response += f"–í—Ä–µ–º—è: {broadcast.scheduled_time.strftime('%Y-%m-%d %H:%M')}\n"
        response += f"–¢–µ–∫—Å—Ç: {preview}\n"
        response += "‚îÄ" * 20 + "\n"
    
    await message.answer(response)
    
@router.message(F.text == "üìã –í—ã–≤–µ—Å—Ç–∏ —Å–ø–∏—Å–æ–∫")
async def show_active_broadcasts(message: types.Message):
    if not is_admin(message.from_user.id):
        await message.answer("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ —Ä–∞—Å—Å—ã–ª–æ–∫")
        return
    
    broadcasts = await get_scheduled_broadcasts()
    
    if not broadcasts:
        await message.answer("üì≠ –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö —Ä–∞—Å—Å—ã–ª–æ–∫")
        return
    
    response = "üìã –ê–∫—Ç–∏–≤–Ω—ã–µ —Ä–∞—Å—Å—ã–ª–∫–∏:\n\n"
    for broadcast in broadcasts:
        # –û–±—Ä–µ–∑–∞–µ–º –¥–ª–∏–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç
        preview = broadcast.message_text[:50] + "..." if len(broadcast.message_text) > 50 else broadcast.message_text
        response += f"ID: {broadcast.id}\n"
        response += f"–í—Ä–µ–º—è: {broadcast.scheduled_time.strftime('%Y-%m-%d %H:%M')}\n"
        response += f"–¢–µ–∫—Å—Ç: {preview}\n"
        response += "‚îÄ" * 20 + "\n"
    
    await message.answer(response)

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —Ä–∞—Å—Å—ã–ª–∫–∏
@router.message(F.text)
async def handle_broadcast_creation(message: types.Message):
    user_id = message.from_user.id
    
    if user_id in user_states and user_states[user_id] == 'awaiting_broadcast_message':
        try:
            # –ü–∞—Ä—Å–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ - –ø–æ—Å–ª–µ–¥–Ω—è—è —Å—Ç—Ä–æ–∫–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –¥–∞—Ç–∞/–≤—Ä–µ–º—è
            lines = message.text.strip().split('\n')
            if len(lines) < 2:
                await message.answer("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –ù—É–∂–µ–Ω —Ç–µ–∫—Å—Ç –∏ –¥–∞—Ç–∞/–≤—Ä–µ–º—è –Ω–∞ —Ä–∞–∑–Ω—ã—Ö —Å—Ç—Ä–æ–∫–∞—Ö")
                return
            
            # –ü–æ—Å–ª–µ–¥–Ω—è—è —Å—Ç—Ä–æ–∫–∞ - –¥–∞—Ç–∞/–≤—Ä–µ–º—è
            datetime_str = lines[-1].strip()
            message_text = '\n'.join(lines[:-1]).strip()
            
            # –ü–∞—Ä—Å–∏–º –¥–∞—Ç—É/–≤—Ä–µ–º—è
            scheduled_time = datetime.strptime(datetime_str, '%Y-%m-%d %H:%M')
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –≤—Ä–µ–º—è –≤ –±—É–¥—É—â–µ–º
            if scheduled_time <= datetime.now():
                await message.answer("‚ùå –í—Ä–µ–º—è –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –≤ –±—É–¥—É—â–µ–º")
                return
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–∞—Å—Å—ã–ª–∫—É
            broadcast_id = await save_broadcast(message_text, scheduled_time)
            
            if broadcast_id:
                # –ü–ª–∞–Ω–∏—Ä—É–µ–º —Ä–∞—Å—Å—ã–ª–∫—É
                schedule_broadcast(broadcast_id, message_text, scheduled_time)
                
                await message.answer(
                    f"‚úÖ –†–∞—Å—Å—ã–ª–∫–∞ –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∞!\n"
                    f"ID: {broadcast_id}\n"
                    f"–í—Ä–µ–º—è: {scheduled_time.strftime('%Y-%m-%d %H:%M')}\n"
                    f"–ü–æ–ª—É—á–∞—Ç–µ–ª–µ–π: {len(await get_all_users())}"
                )
            else:
                await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ —Ä–∞—Å—Å—ã–ª–∫–∏")
            
            # –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
            del user_states[user_id]
            
        except ValueError:
            await message.answer("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞—Ç—ã/–≤—Ä–µ–º–µ–Ω–∏. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: –ì–ì–ì–ì-–ú–ú-–î–î –ß–ß:–ú–ú")
        except Exception as e:
            logger.error(f"Error creating broadcast: {e}")
            await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ —Ä–∞—Å—Å—ã–ª–∫–∏")
            if user_id in user_states:
                del user_states[user_id]

    elif user_id in user_states and user_states[user_id] == 'form_creating_tag_subject_user_id':
        try:
            subject_user_id = message.text.strip()
            
            async with httpx.AsyncClient() as client:
                data = {
                    "created_by_user_id": "ae15f59e-f572-4d28-9ad5-640014288f7b", 
                    "subject_user_id": "43e86fc0-ac1f-4b1f-9025-6bb43da68f3e", 
                    "title": "Gospody",
                    "description": "New",
                    "anonymity": False,
                }
                headers = {
                    "Content-type": "application/json", 
                }
                url = "http://localhost:8000/api/tg/reviews/create"
                response = await client.post(url, data=json.dumps(data), headers=headers)
            
            builder = InlineKeyboardBuilder()
            target_url = "http://127.0.0.1:8000" + response.json()['admin_link']
            print(target_url)
            builder.button(
                text="–ü–µ—Ä–µ–π—Ç–∏ –∫ —Ñ–æ—Ä–º–µ",
                url=target_url
            )

            await message.answer(
                "–£–Ω–∏–∫–∞–ª—å–Ω–∞—è —Å—Å—ã–ª–∫–∞ —Å–æ–∑–¥–∞–Ω–∞, –∂–º–∏ –Ω–∞ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ:",
                reply_markup=builder.as_markup()
            )
                
            del user_states[user_id]
        except Exception as e:
            logger.error(f"Error creating form: {e}")
            await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ —Ñ–æ—Ä–º—ã")
            if user_id in user_states:
                del user_states[user_id]
        
            

# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Ä–∞—Å—Å—ã–ª–∫–∏
async def send_broadcast(broadcast_id: int, message_text: str):
    try:
        users = await get_all_users()
        success_count = 0
        fail_count = 0
        
        for user_id in users:
            try:
                await bot.send_message(user_id, f"üì® –†–∞—Å—Å—ã–ª–∫–∞:\n\n{message_text}")
                success_count += 1
                await asyncio.sleep(0.1)  # –ó–∞–¥–µ—Ä–∂–∫–∞ —á—Ç–æ–±—ã –Ω–µ –ø—Ä–µ–≤—ã—Å–∏—Ç—å –ª–∏–º–∏—Ç—ã
            except Exception as e:
                logger.error(f"Error sending to user {user_id}: {e}")
                fail_count += 1
        
        # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å —Ä–∞—Å—Å—ã–ª–∫–∏
        await update_broadcast_status(broadcast_id, 'completed', success_count, fail_count)
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Ç—á–µ—Ç –∞–¥–º–∏–Ω—É
        report = (
            f"üìä –û—Ç—á–µ—Ç –ø–æ —Ä–∞—Å—Å—ã–ª–∫–µ ID: {broadcast_id}\n"
            f"‚úÖ –£—Å–ø–µ—à–Ω–æ: {success_count}\n"
            f"‚ùå –ù–µ—É–¥–∞—á–Ω–æ: {fail_count}\n"
            f"üìù –¢–µ–∫—Å—Ç: {message_text[:100]}..."
        )
        
        for admin_id in ADMIN_IDS:
            try:
                await bot.send_message(admin_id, report)
            except:
                pass
                
    except Exception as e:
        logger.error(f"Error in broadcast {broadcast_id}: {e}")
        await update_broadcast_status(broadcast_id, 'failed')

# –ü–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–∞—Å—Å—ã–ª–∫–∏
def schedule_broadcast(broadcast_id: int, message_text: str, scheduled_time: datetime):
    async def scheduled_task():
        await send_broadcast(broadcast_id, message_text)
    
    # –í—ã—á–∏—Å–ª—è–µ–º —Ä–∞–∑–Ω–∏—Ü—É –≤–æ –≤—Ä–µ–º–µ–Ω–∏
    now = datetime.now()
    delay = (scheduled_time - now).total_seconds()
    
    if delay > 0:
        asyncio.create_task(schedule_delayed(delay, scheduled_task))

async def schedule_delayed(delay: float, task):
    await asyncio.sleep(delay)
    await task()

# –ó–∞–≥—Ä—É–∑–∫–∞ –∏ –ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö —Ä–∞—Å—Å—ã–ª–æ–∫ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ
async def load_scheduled_broadcasts():
    broadcasts = await get_scheduled_broadcasts()
    for broadcast in broadcasts:
        if broadcast.scheduled_time > datetime.now():
            schedule_broadcast(broadcast.id, broadcast.message_text, broadcast.scheduled_time)
            logger.info(f"–ó–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∞ —Ä–∞—Å—Å—ã–ª–∫–∞ ID: {broadcast.id} –Ω–∞ {broadcast.scheduled_time}")

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤–æ–∑–≤—Ä–∞—Ç–∞ –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é
@router.message(F.text == "‚¨ÖÔ∏è –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é")
async def back_to_main(message: types.Message):
    keyboard = create_main_keyboard()
    await message.answer("–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", reply_markup=keyboard)
    
    # –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∞–¥–º–∏–Ω - —Å–±—Ä–∞—Å—ã–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    if message.from_user.id in user_states:
        del user_states[message.from_user.id]

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /cancel –¥–ª—è –æ—Ç–º–µ–Ω—ã –¥–µ–π—Å—Ç–≤–∏–π
@router.message(Command("cancel"))
async def cmd_cancel(message: types.Message):
    if message.from_user.id in user_states:
        del user_states[message.from_user.id]
        await message.answer("‚ùå –î–µ–π—Å—Ç–≤–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ", reply_markup=create_main_keyboard())
    else:
        await message.answer("–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –¥–µ–π—Å—Ç–≤–∏–π –¥–ª—è –æ—Ç–º–µ–Ω—ã")

# –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è
async def main():
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –ë–î
    await init_db()
    
    # –ó–∞–≥—Ä—É–∂–∞–µ–º –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ä–∞—Å—Å—ã–ª–∫–∏
    await load_scheduled_broadcasts()
    
    logger.info("–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω!")
    
    # –ó–∞–ø—É—Å–∫–∞–µ–º –±–æ—Ç–∞
    await dp.start_polling(bot)

# –û–±—Ä–∞–±–æ—Ç–∫–∞ graceful shutdown
async def shutdown():
    await engine.dispose()
    logger.info("–ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        logger.info("–û—Å—Ç–∞–Ω–æ–≤–∫–∞ –±–æ—Ç–∞...")
        asyncio.run(shutdown())